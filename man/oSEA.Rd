% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oSEA.r
\name{oSEA}
\alias{oSEA}
\title{Function to conduct set enrichment analysis}
\usage{
oSEA(
data,
set,
ig = NULL,
background = NULL,
size.range = c(10, 2000),
min.overlap = 3,
which.distance = NULL,
test = c("fisher", "hypergeo", "binomial"),
background.annotatable.only = NULL,
p.tail = c("one-tail", "two-tails"),
p.adjust.method = c("BH", "BY", "bonferroni", "holm", "hochberg",
"hommel"),
ontology.algorithm = c("none", "pc", "elim", "lea"),
elim.pvalue = 0.01,
lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = FALSE,
verbose = TRUE
)
}
\arguments{
\item{data}{an input vector containing genes (or SNPs)}

\item{set}{an object of class 'SET' to represent annotations or a list
each containg annotations}

\item{ig}{an object of class "igraph" to represent DAG. If provided, it
must have node/vertice attributes: "name" (i.e. "Term Name"), "id"
(i.e. "Term ID"), "namespace" (i.e "Term Namespace") and "distance"
(i.e. Term Distance: the distance to the root; always 0 for the root
itself). By default it is NULL}

\item{background}{a background vector. It contains genes as the test
background. If NULL, by default all annotatable are used as background}

\item{size.range}{the minimum and maximum size of members of each term
in consideration. By default, it sets to a minimum of 10 but no more
than 2000}

\item{min.overlap}{the minimum number of overlaps. Only those terms
with members that overlap with input data at least min.overlap (3 by
default) will be processed}

\item{which.distance}{which terms with the distance away from the
ontology root (if any) is used to restrict terms in consideration. By
default, it sets to 'NULL' to consider all distances}

\item{test}{the test statistic used. It can be "fisher" for using
fisher's exact test, "hypergeo" for using hypergeometric test, or
"binomial" for using binomial test. Fisher's exact test is to test the
independence between gene group (genes belonging to a group or not) and
gene annotation (genes annotated by a term or not), and thus compare
sampling to the left part of background (after sampling without
replacement). Hypergeometric test is to sample at random (without
replacement) from the background containing annotated and non-annotated
genes, and thus compare sampling to background. Unlike hypergeometric
test, binomial test is to sample at random (with replacement) from the
background with the constant probability. In terms of the ease of
finding the significance, they are in order: hypergeometric test >
fisher's exact test > binomial test. In other words, in terms of the
calculated p-value, hypergeometric test < fisher's exact test <
binomial test}

\item{background.annotatable.only}{logical to indicate whether the
background is further restricted to the annotatable. By default, it is
NULL: if ontology.algorithm is not 'none', it is always TRUE;
otherwise, it depends on the background (if not provided, it will be
TRUE; otherwise FALSE). Surely, it can be explicitly stated}

\item{p.tail}{the tail used to calculate p-values. It can be either
"two-tails" for the significance based on two-tails (ie both over- and
under-overrepresentation) or "one-tail" (by default) for the
significance based on one tail (ie only over-representation)}

\item{p.adjust.method}{the method used to adjust p-values. It can be
one of "BH", "BY", "bonferroni", "holm", "hochberg" and "hommel". The
first two methods "BH" (widely used) and "BY" control the false
discovery rate (FDR: the expected proportion of false discoveries
amongst the rejected hypotheses); the last four methods "bonferroni",
"holm", "hochberg" and "hommel" are designed to give strong control of
the family-wise error rate (FWER). Notes: FDR is a less stringent
condition than FWER}

\item{ontology.algorithm}{the algorithm used to account for the
hierarchy of the ontology. It can be one of "none", "pc", "elim" and
"lea". For details, please see 'Note' below}

\item{elim.pvalue}{the parameter only used when "ontology.algorithm" is
"elim". It is used to control how to declare a signficantly enriched
term (and subsequently all genes in this term are eliminated from all
its ancestors)}

\item{lea.depth}{the parameter only used when "ontology.algorithm" is
"lea". It is used to control how many maximum depth is used to consider
the children of a term (and subsequently all genes in these children
term are eliminated from the use for the recalculation of the
signifance at this term)}

\item{path.mode}{the mode of paths induced by vertices/nodes with input
annotation data. It can be "all_paths" for all possible paths to the
root, "shortest_paths" for only one path to the root (for each node in
query), "all_shortest_paths" for all shortest paths to the root (i.e.
for each node, find all shortest paths with the equal lengths)}

\item{true.path.rule}{logical to indicate whether the true-path rule
should be applied to propagate annotations. By default, it sets to
true}

\item{verbose}{logical to indicate whether the messages will be
displayed in the screen. By default, it sets to true for display}
}
\value{
an object of class "eSET", a list with following components:
\itemize{
\item{\code{data}: a tibble containing a column 'data' for input data
analysed}
\item{\code{background}: a tibble containing a column 'background' for
the background used}
\item{\code{ig}: NULL or an "igraph" object}
\item{\code{info}: a tibble of nSet X 14 containing set enrichment
information, where nSet is the number of sets, and the 14 columns
including "id" (set ID), "name" (set name), "nA" (number of
annotations), "nO" (number of overlaps), "fc" (fold change), "zscore"
(z-score), "pvalue" (p-value), "adjp" (adjusted p-value), "or" (odds
ratio), "CIl" (lower bound confidence interval for the odds ratio),
"CIu" (upper bound confidence interval for the odds ratio), "distance"
(distance to the root), "namespace", "overlap" (the detailed members
for overlaps)}
}
}
\description{
\code{oSEA} is supposed to conduct set enrichment analysis (SEA) given
the input data, annotation and/or ontology. The annotation is provided
as an object of class "SET", while the ontology as an object of class
"igraph", usually direct acyclic graph (DAG). It returns an object of
class "eSET". Enrichment analysis is based on either Fisher's exact
test or Hypergeometric test. The test can respect the hierarchy of the
ontology.
}
\note{
The interpretation of the algorithms used to account for the hierarchy
of the ontology is:
\itemize{
\item{"none": does not consider the ontology hierarchy at all.}
\item{"lea": estimates the significance of a term in terms of the
significance of its children at the maximum depth (e.g. 2). Precisely,
once snps/genes are already annotated to any children terms with a more
signficance than itself, then all these snps/genes are eliminated from
the use for the recalculation of the signifance at that term. The final
p-values takes the maximum of the original p-value and the recalculated
p-value.}
\item{"elim": estimates the significance of a term in terms of the
significance of its all children. Precisely, once snps/genes are
already annotated to a signficantly enriched term under the cutoff of
e.g. pvalue<1e-2, all these snps/genes are eliminated from the
ancestors of that term).}
\item{"pc": requires the significance of a term not only using the
whole snps/genes as background but also using snps/genes annotated to
all its direct parents/ancestors as background. The final p-value takes
the maximum of both p-values in these two calculations.}
\item{"Notes": the order of the number of significant terms is: "none"
> "lea" > "elim" > "pc".}
}
}
\examples{
\dontrun{
BioGRID_HCoV <- oRDS("BioGRID_HCoV", placeholder=placeholder)
data <- BioGRID_HCoV \%>\% filter(from_tax==2697049) \%>\% count(to)
\%>\% pull(to)

# Bucket
set <- oRDS("org.Hs.egBucket", placeholder=placeholder)
ig <- oRDS("ig.Bucket", placeholder=placeholder)
# KEGG
set <- oRDS("org.Hs.egKEGG", placeholder=placeholder)
set <- oRDS("org.Hs.egKEGGGeneticProcess", placeholder=placeholder)
ig <- oRDS("ig.KEGG", placeholder=placeholder)
# REACTOME
set <- oRDS("org.Hs.egREACTOME", placeholder=placeholder)
ig <- oRDS("ig.REACTOMEslim", placeholder=placeholder)
# GOMF
set <- oRDS("org.Hs.egGOMF", placeholder=placeholder)
ig <- oRDS("ig.GOMF", placeholder=placeholder)
# org.Hs.egMsigdb
set <- oRDS("org.Hs.egMsigdb", placeholder=placeholder)
ig <- oRDS("ig.Msigdb", placeholder=placeholder)
# org.Hs.egEnrichr
set <- oRDS("org.Hs.egEnrichr", placeholder=placeholder)
set2 <- set; set2$info <- set2$info \%>\%
filter(!str_detect(namespace,'L1000'))

eset <- oSEA(data, set, ig)
eset$ig
eset \%>\% oSEAextract() \%>\% write_delim('results_eset.txt','\t')
eset \%>\% oSEAextract() \%>\% filter(distance=='DiseaseDrug') \%>\%
oSEAforest(top=2)
eset \%>\% oSEAextract() \%>\% filter(adjp<0.01) \%>\%
group_by(namespace) \%>\% top_n(2,-adjp) \%>\% ungroup() \%>\%
oSEAwheel(ig, fixed=F, edge.color='namespace',
leaf.label.orientation='outwards',
leaf.label.expansion=1.15,limit.expansion=2, leaf.label.size=1.5)

# ggraph 
## 1) based on eset$ig (default)
gp <- oSEAggraph(eset, fixed=F, leave=F, slim=c(0,10),
node.label.direction="leftright")
## 2) based on eset$ig (shortest version)
subg <- oDAGinduce(eset$ig, path.mode="shortest_paths")
gp <- oSEAggraph(eset, subg, fixed=F, leave=F, slim=c(0,10),
node.label.direction="leftright")
## 3) based on eset$ig (the clade "")
#eset$ig \%>\% oIG2TB('nodes') \%>\% filter(distance==1) \%>\% arrange(IC) \%>\% pull(name)
clade <- oDAGclade(eset$ig, 'catalytic activity')
gp <- oSEAggraph(eset, clade, fixed=F, leave=F, slim=c(0,10),
node.label.direction="leftright")
## 4) do comparisons
gp <- oSEAggraph(eset, fixed=F, slim=c(0,10), node.label.size=0)
gp1 <- oSEAggraph(eset, subg, fixed=F, slim=c(0,10), node.label.size=0)
gp2 <- oSEAggraph(eset, clade, fixed=F, slim=c(0,10),
node.label.size=0)
library(patchwork)
gp + gp1 + gp2 + plot_layout(guides='collect')

# advanced visual
gp <- oSEAggraph(df, fixed=F, leave=F, layout='dendrogram',
node.label.size=0)
## alternative
eset$info \%>\% filter(adjp<0.05) -> df
eset$ig \%>\% oDAGtree() -> ig.tree
gp <- oSEAggraph(df, ig.tree, fixed=F, leave=F, layout='dendrogram',
node.label.size=0)
## labelling
gp + ggraph::geom_node_text(aes(x=x*1.1, y=y*1.1, filter=leaf,
label=name, angle=node_angle(x,y)), repel=F, hjust=0, size=2) +
expand_limits(x=c(-2,2), y=c(-2,2)) -> gp
gp + geom_edge_diagonal2(aes(color=node.term_namespace,
alpha=stat(index)),width=0.2) + guides(edge_alpha=F) -> gp1
gp1 + theme(legend.box='vertical') +
guides(edge_colour=guide_legend('namespace',direction="vertical"),
size=guide_legend('-log10(FDR)','top',direction="horizontal",ncol=3),
color=guide_colorbar('Z-score','top',direction="horizontal",barheight=0.5))
+ theme(legend.position='right')
}
}
\seealso{
\code{\link{oSEA}}
}
